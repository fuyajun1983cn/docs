--- 
layout: default
---
<div class="header">
  <div class="jumbotron">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>netlink学习记录</h1>
          <p>简要阐述了Linux内核中关于netlink的实现机制以及内核与用户空间通过netlink进行通信的实例。</p>
        </div>
      </div>
    </div>
  </div>
</div>




<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">netlink学习记录</h1>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">netlink要点记录</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">netlink与IOCTL的对比</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>都是用户空间与内核空间进行通信的一种方式。
</li>
<li>IOCTL不能从内核空间发送异步消息到用户空间。
</li>
<li>netlink支持内核空间与用户空间的双向通信。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">netlink家族</h3>
<div class="outline-text-3" id="text-1-2">
<p>
netlink是一种基于socket的进程间通信协议，基于RFC3549. 它提供了用户
空间与内核空间以及内核模块之间的通信机制。netlink协议的主要实现文
件位于 <code>net/netlink</code> 目录下，主要包含有如下4个重要文件：
</p>
<ul class="org-ul">
<li><code>af_netlink.c</code>
</li>
<li><code>af_netlink.h</code>
</li>
<li><code>genetlink.c</code>
</li>
<li><code>diag.c</code>
</li>
</ul>
<p>
比较重要的模块主要有：
</p>
<ol class="org-ol">
<li><code>af_netlink</code> : netlink kernel socket.
</li>
<li><code>genetlink</code> : a new generic netlink API to easily create
netlink messages.
</li>
<li><code>diag</code> : provides an API to dump and to get information about
the netlink sockets. 
</li>
</ol>
<p>
可以通过 <code>socket()</code> 系统调用创建 <code>netlink socket</code> ， 类型可为：
<code>SOCK_RAW</code> , <code>SOCK_DGRAM</code> . 从内核空间也可以创建 <code>netlink socket</code>,
可以使用 <code>netlink_kernel_create()</code> 接口。不管是从用户空间创建
<code>netlink socket</code> 还是从内核空间创建 <code>netlink socket</code>, 最终都会调用
<code>__netlink_create()</code> . 
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016010401.png" class="img-responsive" alt="2016010401.png">
</p>
<figcaption><span class="figure-number">Figure 1:</span> Creating a netlink socket in the kernel and in userspace</figcaption>
</figure>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Netlink Socket库</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
一般使用 <code>libnl</code> 库来开发 <code>netlink socket</code> 相关的用户空间程序。
<code>libnl</code> 库提供了一组API来访问基于 netlink protocol 的Linux接口。
它主要包含如下几个库：
</p>
<ul class="org-ul">
<li>libnl core library
</li>
<li>libnl-genl: generic netlink family
</li>
<li>libnl-route: routing family
</li>
<li>libnl-nf: netfilter family.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><code>sockaddr_nl</code> 结构</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
该数据结构代表一个netlink socket地址。
</p>
<div class="org-src-container">

<pre class="src src-c">struct sockaddr_nl {
  __kernel_sa_family_t nl_family; /* AF_NETLINK */
  unsigned short nl_pad; /* zero */
  __u32 nl_pid; /* port ID */
  __u32 nl_groups; /* multicast groups mask */
};
</pre>
</div>

<p>
数据结构说明：
</p>
<ol class="org-ol">
<li><code>nl_family</code> : 该值总是为 <code>AF_NETLINK</code> 。
</li>
<li><code>nl_pad</code> : 该值总是为0.
</li>
<li><code>nl_pid</code> : 一个netlink socket的单播地址，对于内核netlink
socket，该值为0. 用户空间的netlink socket，通常是该进程的PID。
</li>
<li><code>nl_groups</code> : The multicast group(or multicast group mask)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Kernel Netlink Socket</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
在内核网络协议栈中，创建了一些不同的netlink socket，分别处理不
同类型的消息。 例如处理 <code>NETLINK_ROUTE</code> ，初始化代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c">static int __net_init rtnetlink_net_init(struct net *net) {
  ...
  struct netlink_kernel_cfg cfg = {
    .groups = RTNLGRP_MAX,
    .input = rtnetlink_rcv,
    .cb_mutex = &amp;rtnl_mutex,
    .flags = NL_CFG_F_NONROOT_RECV,
  };
  sk = netlink_kernel_create(net, NETLINK_ROUTE, &amp;cfg);
  ...
}
</pre>
</div>

<p>
socket创建时，会使用 <code>struct netlink_kernel_cfg</code> 数据结构：
</p>
<div class="org-src-container">

<pre class="src src-c">struct netlink_kernel_cfg {
  unsigned int groups;
  unsigned int flags;
  void (*input)(struct sk_buff *skb);
  struct mutex *cb_mutex;
  void (*bind)(int group);
};
(include/uapi/linux/netlink.h)
</pre>
</div>

<p>
数据结构说明如下：
</p>
<ul class="org-ul">
<li><code>groups</code> : 用于指定多播组或掩码。可以使用
<code>NETLINK_ADD_MEMBERSHIP/ NETLINK_DROP_MEMBERSHIP</code> socket选项
加入/离开一个多播组。 <code>libnl</code> 库提供了两个接口分别设置上述两
个标记：
<code>nl_socket_add_memberships()/nl_socket_drop_membership()</code> 。 
</li>
<li><code>flags</code> : 值可以为： <code>NL_CFG_F_NONROOT_RECV</code> or
<code>NL_CFG_F_NONROOT_SEND</code> . 
当设置了 <code>CFG_F_NONROOT_RECV</code> , 非root用户可以绑定到一个多播
组：
<div class="org-src-container">

<pre class="src src-c">static int netlink_bind(struct socket *sock, struct sockaddr *addr,
int addr_len)
{
  ...
  if (nladdr-&gt;nl_groups) {
    if (!netlink_capable(sock, NL_CFG_F_NONROOT_RECV))
      return -EPERM;
  }
</pre>
</div>
</li>
<li><code>input</code> : 一个回调函数，当为NULL时，内核socket将不会收到来自
用户空间的数据。
</li>
<li><code>cb_mutex</code> : 可选的，可以不用定义，使用默认的 <code>cb_def_mutex</code> 
</li>
</ul>

<p>
<code>netlink_kernel_create</code> 会通过 <code>netlink_insert()</code> 方法向
<code>nl_table</code> 中插入一个项。 <code>nl_lookup</code> 用于查询一个表项。
</p>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">注册一个 <code>netlink socket</code></h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
以 <code>rtnl_register</code> 方法为例子。 
</p>
<div class="org-src-container">

<pre class="src src-c">extern void rtnl_register(int protocol, int msgtype,
                          rtnl_doit_func,
                          rtnl_dumpit_func,
                          rtnl_calcit_func);
</pre>
</div>
<ul class="org-ul">
<li><code>protocol</code> : protocol类型定义在include/linux/socket.h
</li>
<li>netlink消息类型： <code>RTM_NEWLINK</code> or <code>RTM_NEWNEIGH</code>
</li>
<li><code>doit</code> : addition/deletion/modification回调函数。
</li>
<li><code>dumpit</code> : 检索信息, clear data after completion of command
or on error.
</li>
<li><code>calcit</code> : 计算buffer的大小。 
</li>
</ul>

<p>
<code>rtnetlink</code> 模块有一个表名为: <code>rtnl_msg_handlers</code> . 该表通过协
  议号索引。 表中的每一项本身也是一个表，通过消息类型索引。表中
  的每个元素为一个 <code>rtnl_link</code> 实例，该结构刚好包含了这三个回调
  函数。
</p>
<div class="org-src-container">
<label class="org-src-name"><code>__rtnl_register</code> 源码</label>
<pre class="src src-c">int __rtnl_register(int protocol, int msgtype,
                    rtnl_doit_func doit, rtnl_dumpit_func dumpit,
                    rtnl_calcit_func calcit)
{
        struct rtnl_link *tab;
        int msgindex;

        BUG_ON(protocol &lt; 0 || protocol &gt; RTNL_FAMILY_MAX);
        msgindex = rtm_msgindex(msgtype);

        tab = rtnl_msg_handlers[protocol];
        if (tab == NULL) {
                tab = kcalloc(RTM_NR_MSGTYPES, sizeof(*tab), GFP_KERNEL);
                if (tab == NULL)
                        return -ENOBUFS;

                rtnl_msg_handlers[protocol] = tab;
        }

        if (doit)
                tab[msgindex].doit = doit;

        if (dumpit)
                tab[msgindex].dumpit = dumpit;

        if (calcit)
                tab[msgindex].calcit = calcit;

        return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">发送一个 <code>netlink socket</code> 消息</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
rtnetlink消息是通过 <code>rtmsg_ifinfo()</code> 发送的。 
</p>

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016010402.png" class="img-responsive" alt="2016010402.png">
</p>
<figcaption><span class="figure-number">Figure 2:</span> Sending of rtnelink messages with the <code>rtmsg_ifinfo()</code> method</figcaption>
</figure>

<ul class="org-ul">
<li><code>nlmsg_net()</code> 分配一个 <code>sk_buffer</code> 对象
</li>
<li><code>rtnl_fill_ifinfo()</code> 填充要发送的数据信息
</li>
<li><code>rt_nl_notify()</code> 通过 <code>nlmsg_notify()</code> 发送消息。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">Netlink的消息格式</h4>
<div class="outline-text-4" id="text-1-2-6">
<div class="org-src-container">

<pre class="src src-c">struct nlmsghdr
{
  __u32 nlmsg_len;
  __u16 nlmsg_type;
  __u16 nlmsg_flags;
  __u32 nlmsg_seq;
  __u32 nlmsg_pid;
};
(include/uapi/linux/netlink.h)
</pre>
</div>

<ul class="org-ul">
<li><code>nlmsg_len</code> : 消息长度（包含头部）
</li>
<li><code>nlmsg_type</code> : 消息类型， 主要包含如下4种基本的消息类型：
<ol class="org-ol">
<li><code>NLMSG_NOOP</code>: 无操作，消息会被丢弃。
</li>
<li><code>NLMSG_ERROR</code> : 有错误发生。
</li>
<li><code>NLMSG_DONE</code> : 分段消息已经发送完成。
</li>
<li><code>NLMSG_OVERRUN</code> ：错误，数据丢失。
</li>
</ol>
<p>
此外，还可以自定义一些消息类型，消息类型值小于
<code>NLMSG_MIN_TYPE (0x10)</code> 会保留为控制消息使用。
</p>
</li>
<li><code>nlmsg_flags</code> : 可为如下一些值：
<ul class="org-ul">
<li><code>NLM_F_REQUEST</code>
</li>
<li><code>NLM_F_MULTI</code>
</li>
<li><code>NLM_F_ACK</code>
</li>
<li><code>NLM_F_DUMP</code>
</li>
<li><code>NLM_F_ROOT</code>
</li>
<li><code>NLM_F_MATCH</code>
</li>
<li><code>NLM_F_ATOMIC</code> : This flag is deprecated.
</li>
<li><code>LM_F_REPLACE</code> : Override existing entry
</li>
<li><code>NLM_F_EXCL</code> : Do not touch entry, if it exists
</li>
<li><code>NLM_F_CREATE</code> :  Create entry, if it does not exist.
</li>
<li><code>NLM_F_APPEND</code> : Add entry to end of list.
</li>
<li><code>NLM_F_ECHO</code> : Echo this request.
</li>
</ul>
</li>
<li><code>nlmsg_seq</code> : 消息序列号。
</li>
<li><code>nlmsg_pid</code> : 发送方的 port id。 
</li>
</ul>

<p>
头部消息之后紧跟着负载，负载是由一系列TLV格式包装的属性构成。
</p>
<div class="org-src-container">

<pre class="src src-c">struct nlattr {
  __u16 nla_len;
  __u16 nla_type;
};
(include/uapi/linux/netlink.h)
</pre>
</div>
<ul class="org-ul">
<li><code>nla_len</code> : 属性值的大小
</li>
<li><code>nla_type</code> : 主要有 <code>NLA_U32</code> , <code>NLA_STRING</code> , <code>NLA_NESTED</code> ,
<code>NLA_UNSPEC</code>, 可用类型的列表： include/net/netlink.h
</li>
</ul>

<p>
每个netlink家族也会定义一个属性验证策略，用数据结构 <code>struct
     nla_policy</code> 表示：
</p>
<div class="org-src-container">

<pre class="src src-c">struct nla_policy {
  u16 type;
  u16 len;
};
(include/uapi/linux/netlink.h)
</pre>
</div>
<ul class="org-ul">
<li>当 <code>nla_policy</code> 的 <code>len</code> 值为0， 则不需要做任何验证。
</li>
<li>对于 <code>NLA_STRING</code> 类型的属性， <code>len</code> 值为字符串的最大长度，不
包含未尾的NULL结束符。
</li>
<li>对于 <code>NLA_UNSPEC</code> 类型的属性， <code>len</code> 值为负载的长度。
</li>
<li>对于 <code>NLA_FLAG</code> 类型的属性， <code>len</code> 值未使用。
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Generic Netlink协议</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<code>netlink协议</code> 的一大缺点是： 协议家族的数量限制为32个(MAX<sub>LINKS</sub>)。
为了支持更多的协议家族，创建了 <code>netlink</code> ， 它是一个 <code>netlink复用
     器</code> , 家族名称为 <code>NETLINK_GENERIC</code> 。可以在 <code>generic netlink</code> 之
上添加新的 <code>netlink家族</code> 。 
<code>generic netlink socket</code> 本身的初始化（注册）如下：
</p>
<div class="org-src-container">

<pre class="src src-c">static int __net_init genl_pernet_init(struct net *net) {
  ..
  struct netlink_kernel_cfg cfg = {
    .input = genl_rcv,
    .cb_mutex = &amp;genl_mutex,
    .flags = NL_CFG_F_NONROOT_RECV,
  };
  net-&gt;genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &amp;cfg);
  ...
}
(net/netlink/genetlink.c)
</pre>
</div>
<p>
从用户空间发往内核的 <code>generic netlink socket</code> 的消息将会由
<code>genl_rcv</code> 来接收和处理。 
</p>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Generic Netlink Family</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
内核中使用 <code>generic netlink socket</code>  ， 步骤如下：
</p>
<ol class="org-ol">
<li>Create a <code>genl_family</code> object and register it by calling <code>genl_register_family()</code>.
</li>
<li>Create a <code>genl_ops</code> object and register it by calling <code>genl_register_ops()</code>.
</li>
</ol>
<p>
上述两步可以通过 <code>genl_register_family_with_ops()</code> 一步完成。 
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016010404.png" class="img-responsive" alt="2016010404.png">
</p>
<figcaption><span class="figure-number">Figure 3:</span> Genl Family and Ops注册相关数据结构</figcaption>
</figure>

<p>
例如， 802.11使用 <code>generic netlink socket</code> 注册相关的处理函数：
</p>
<div class="org-src-container">

<pre class="src src-c">int nl80211_init(void)
{
  int err;
  err = genl_register_family_with_ops(&amp;nl80211_fam,
                                      nl80211_ops, ARRAY_SIZE(nl80211_ops));
  ...
}
(net/wireless/nl80211.c)
</pre>
</div>

<p>
nl80211相关定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">static struct genl_family nl80211_fam = {
  .id = GENL_ID_GENERATE, /* don't bother with a hardcoded ID */
  .name = "nl80211", /* have users key off the name instead */
  .hdrsize = 0, /* no private header */
  .version = 1, /* no particular meaning now */
  .maxattr = NL80211_ATTR_MAX,
  .netnsok = true,
  .pre_doit = nl80211_pre_doit,
  .post_doit = nl80211_post_doit,
};
</pre>
</div>
<ul class="org-ul">
<li><code>name</code> : 唯一的名称
</li>
<li><code>id</code> : 动态申请 16 ( <code>GENL_MIN_ID</code>, which is 0x10) to 1023 (
<code>GENL_MAX_ID</code>).
</li>
<li><code>hdrsize</code> : 私有头部的大小。
</li>
<li><code>maxattr</code> : 所支持的属性的最大值： <code>NL80211_ATTR_MAX</code>
</li>
<li><code>netnsok</code> : 该家族是否可以处理网络空间。
</li>
<li><code>pre_doit</code> : 调用 <code>doit()</code> 前的一个钩子函数。
</li>
<li><code>post_doit</code> : 调用 <code>doit()</code> 后的一个钩子函数。 
</li>
</ul>

<p>
定义相关的命令：
</p>
<div class="org-src-container">

<pre class="src src-c">struct genl_ops {
  u8 cmd;
  u8 internal_flags;
  unsigned int flags;
  const struct nla_policy *policy;
  int (*doit)(struct sk_buff *skb,struct genl_info *info);
  int (*dumpit)(struct sk_buff *skb,
                struct netlink_callback *cb);
  int (*done)(struct netlink_callback *cb);
  struct list_head ops_list;
};
</pre>
</div>
<ul class="org-ul">
<li><code>cmd</code> : 命令标识。
</li>
<li><code>internal_flags</code> : 家族定义的一些私有标记。
</li>
<li><code>flags</code> : 操作标记。
<ul class="org-ul">
<li><code>GENL_ADMIN_PERM</code> : 当设置了该标记，表明该操作需要
<code>CAP_NET_ADMIN</code> 权限。
</li>
<li><code>GENL_CMD_CAP_DO</code> : 当设置了该标记， 表明 <code>genl_ops</code> 结构实
现了 <code>doit()</code> 回调函数。
</li>
<li><code>GENL_CMD_CAP_DUMP</code> : 当设置了该标记，表明 <code>genl_ops</code> 结构实
现了 <code>dumpit()</code> 回调函数。
</li>
<li><code>GENL_CMD_CAP_HASPOL</code> : 当设置了该标记， 表明 <code>genl_ops</code> 结
构定义了属性验证策略( <code>nla_policy</code> 数组)。
</li>
</ul>
</li>
<li><code>policy</code> : 属性验证策略。
</li>
<li><code>doit</code> : 标准的命令回调函数。
</li>
<li><code>dumpit</code> : dump的回调函数。
</li>
<li><code>done</code> : Completion callback for dumps
</li>
<li><code>ops_list</code> : 操作列表 。
<div class="org-src-container">

<pre class="src src-c">static struct genl_ops nl80211_ops[] = {
{
  ...
  {
    .cmd = NL80211_CMD_GET_SCAN,
    .policy = nl80211_policy,
    .dumpit = nl80211_dump_scan,
  },
  ...
}
</pre>
</div>
</li>
</ul>
</div>

<ul class="org-ul"><li><a id="sec-1-3-1-1" name="sec-1-3-1-1"></a>一个示例<br ><div class="outline-text-5" id="text-1-3-1-1">
<p>
注册一个Generic Netlink Family可以细分为4个步骤：
</p>
<ol class="org-ol">
<li>定义Family
这步需要定义一个 <code>genl_family</code> 结构体实例。
<div class="org-src-container">

<pre class="src src-c">/* attributes */
 enum {
       DOC_EXMPL_A_UNSPEC,
       DOC_EXMPL_A_MSG,
       __DOC_EXMPL_A_MAX,
 };
 #define DOC_EXMPL_A_MAX (__DOC_EXMPL_A_MAX - 1)
 /* attribute policy */
 static struct nla_policy doc_exmpl_genl_policy[DOC_EXMPL_A_MAX + 1] = {
       [DOC_EXMPL_A_MSG] = { .type = NLA_NUL_STRING },
 };
 /* family definition */
 static struct genl_family doc_exmpl_gnl_family = {
       .id = GENL_ID_GENERATE,
       .hdrsize = 0,
       .name = "DOC_EXMPL",
       .version = 1,
       .maxattr = DOC_EXMPL_A_MAX,
 };
</pre>
</div>
</li>

<li>定义操作
创建一个 <code>genl_ops</code> 结构体实例。
<div class="org-src-container">

<pre class="src src-c">/* handler */
static int doc_exmpl_echo(struct sk_buff *skb, struct genl_info *info)
{
      /* message handling code goes here; return 0 on success, negative
       * values on failure */
}
/* commands */
enum {
      DOC_EXMPL_C_UNSPEC,
      DOC_EXMPL_C_ECHO,
      __DOC_EXMPL_C_MAX,
};
#define DOC_EXMPL_C_MAX (__DOC_EXMPL_C_MAX - 1)
/* operation definition */
static struct genl_ops doc_exmpl_gnl_ops_echo = {
      .cmd = DOC_EXMPL_C_ECHO,
      .flags = 0,
      .policy = doc_exmpl_genl_policy,
      .doit = doc_exmpl_echo,
      .dumpit = NULL,
};
</pre>
</div>

<p>
通过Generic Netlink发送 <code>DOC_EXMPL_C_ECHO</code> 消息都会最终通过
<code>doc_exmpl_echo</code> 函数处理。
</p>
</li>
<li>注册Family
通过 <code>genl_register_family</code> 注册Family:
<div class="org-src-container">

<pre class="src src-c">int rc;
 rc = genl_register_family(&amp;doc_exmpl_gnl_family);
 if (rc != 0)
     goto failure;
</pre>
</div>
<p>
当不再需要时，也有必要进行注销操作，避免浪费内核资源。
</p>
</li>
<li>注册操作。
通过 <code>genl_register_ops</code> 注册操作：
<div class="org-src-container">

<pre class="src src-c">int rc;
 rc = genl_register_ops(&amp;doc_exmpl_gnl_family, &amp;doc_exmpl_gnl_ops_echo);
 if (rc != 0)
     goto failure;
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">创建和发送 <code>Generic Netlink消息</code></h4>
<div class="outline-text-4" id="text-1-3-2">
</div><ul class="org-ul"><li><a id="sec-1-3-2-1" name="sec-1-3-2-1"></a><code>Generic Header</code><br ><div class="outline-text-5" id="text-1-3-2-1">

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016010403.png" class="img-responsive" alt="2016010403.png">
</p>
</figure>

<p>
其中 <code>genlmsghdr</code> 定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">struct genlmsghdr {
  __u8 cmd;
  __u8 version;
  __u16 reserved;
};
(include/uapi/linux/genetlink.h)
</pre>
</div>

<ul class="org-ul">
<li><code>cmd</code> : 一种 <code>generic netlink</code> 消息类型，每个家族都会定义自己
的命令。
</li>
<li><code>version</code> : 提供版本支持。
</li>
<li><code>reserved</code> : 保留为后续使用。
</li>
</ul>

<p>
分配一个 <code>generic netlink buffer</code> ：
</p>
<div class="org-src-container">

<pre class="src src-c">sk_buff *genlmsg_new(size_t payload, gfp_t flags)
</pre>
</div>

<p>
发送单播消息： <code>genlmsg_unicast()</code> . 
发送多播消息： <code>genlmsg_multicast()</code> , 发送多播消息到默认的网络
命名空间(net<sub>init</sub>). <code>genlmsg_multicast_allns()</code> , 发送多播消息到
所有的网络命名空间。
</p>

<p>
在用户空间可以调用如下接口创建一个 <code>generic netlink socket</code> ， 
</p>
<div class="org-src-container">

<pre class="src src-c">socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-3-2-2" name="sec-1-3-2-2"></a>发送消息<br ><div class="outline-text-5" id="text-1-3-2-2">
<p>
发送一个Generic Netlink消息主要分为三步：
</p>
<ol class="org-ol">
<li>创建 一个Buffer存储消息。
<div class="org-src-container">

<pre class="src src-c">struct sk_buff *skb;
 skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
 if (skb == NULL)
     goto failure;
</pre>
</div>
<p>
当事先不知道要分配多大空间时，可以传入 <code>NLMSG_GOODSIZE</code> ， 另
外， <code>genlmsg_new()</code> 会自动加上  Netlink和 Generic Netlink的
空间。
</p>
</li>
<li>创建消息实例。

<div class="org-src-container">

<pre class="src src-c">int rc;
void *msg_head;
/* create the message headers */
msg_head = genlmsg_put(skb, pid, seq, type, 0, flags, DOC_EXMPL_C_ECHO, 1);
if (msg_head == NULL) {
    rc = -ENOMEM;
    goto failure;
}
/* add a DOC_EXMPL_A_MSG attribute */
rc = nla_put_string(skb, DOC_EXMPL_A_MSG, "Generic Netlink Rocks");
if (rc != 0)
    goto failure;
/* finalize the message */
genlmsg_end(skb, msg_head);
</pre>
</div>
</li>

<li>发送消息。

<div class="org-src-container">

<pre class="src src-c">int rc;
 rc = genlmsg_unicast(skb, pid);
 if (rc != 0)
     goto failure;
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>


<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">libnl-genl库</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
使用该库，可以通过 <code>genl_connect()</code> 创建一个本地的socket文件描
述符，并将socket绑定到 <code>NETLINK_GENERIC</code> netlink协议 。
</p>

<p>
用户空间通过 <code>libnl-genl</code> 发送一条消息的流程如下：
</p>
<ol class="org-ol">
<li>创建Socket： 
<div class="org-src-container">

<pre class="src src-c">state-&gt;nl_sock = nl_socket_alloc()
</pre>
</div>
</li>
<li>创建 <code>NETLINK_GENERIC</code> 类型的socket，并调用 <code>bind()</code> ：
<div class="org-src-container">

<pre class="src src-c">genl_connect(state-&gt;nl_sock)
</pre>
</div>
</li>
<li>解析该 netlink family name对应的family id:
<div class="org-src-container">

<pre class="src src-c">genl_ctrl_resolve(state-&gt;nl_sock, "nl80211");
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">使用建议</h4>
<div class="outline-text-4" id="text-1-3-4">
<ol class="org-ol">
<li>make use of the Netlink attributes wherever possible.
<ul class="org-ul">
<li><b>scalar values</b> :  Most scalar values already have
well-defined attribute types; see section 4 for details.
</li>
<li><b>structures</b> :  Structures can be represented using a nested
attribute with the structure fields represented as
attributes in the payload of the container attribute.
</li>
<li><b>arrays</b> : Arrays can be represented by using a single
nested attribute as a container with several of the same
attribute type inside each representing a spot in the
array.
</li>
</ul>
</li>
<li>use unique attributes as much as possible.
</li>
<li>don't register a single operation for a Generic Netlink
family and multiplex multiple sub-commands on the single
operation.
</li>
<li>It is often necessary for Generic Netlink services to return
an ACK or error code to the client. 
</li>
</ol>

<p>
参考资料： <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/generic_netlink_howto"><code>generic_netlink_howto</code></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">ROUTE netlink</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<code>NETLINK_ROUTE</code> 协议用于更新路由表，配置网络接口时的链路参数，为网
络接口配置IP地址时的地址信息，入队规则，数据流量分类，为不同类型数
据流量配置过滤器， 设置路由规则等等，它控制了网络路由系统。
</p>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">LINK Parameter Messages</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
set and retrieve information about the network interfaces on
the system. It consists of the following message types:
</p>
<ol class="org-ol">
<li><code>RTM_NEWLINK</code>
</li>
<li><code>RTM_DELLINK</code>
</li>
<li><code>RTM_GETLINK</code>
</li>
</ol>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1-1" name="sec-1-4-1-1"></a>Monitor for new links using Python and Netlink<br ><div class="outline-text-5" id="text-1-4-1-1">
<div class="org-src-container">

<pre class="src src-python">import os
import socket
import struct

# These constants map to constants in the Linux kernel. This is a crappy
# way to get at them, but it'll do for now.
RTMGRP_LINK = 1

NLMSG_NOOP = 1
NLMSG_ERROR = 2

RTM_NEWLINK = 16
RTM_DELLINK = 17

IFLA_IFNAME = 3

# Create the netlink socket and bind to RTMGRP_LINK,
s = socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, socket.NETLINK_ROUTE)
s.bind((os.getpid(), RTMGRP_LINK))

while True:
    data = s.recv(65535)
    msg_len, msg_type, flags, seq, pid = struct.unpack("=LHHLL", data[:16])

    if msg_type == NLMSG_NOOP:
        print "no-op"
        continue
    elif msg_type == NLMSG_ERROR:
        print "error"
        break

    # We fundamentally only care about NEWLINK messages in this version.
    if msg_type != RTM_NEWLINK:
        continue

    data = data[16:]

    family, _, if_type, index, flags, change = struct.unpack("=BBHiII", data[:16])

    remaining = msg_len - 32
    data = data[16:]

    while remaining:
        rta_len, rta_type = struct.unpack("=HH", data[:4])

        # This check comes from RTA_OK, and terminates a string of routing
        # attributes.
        if rta_len &lt; 4:
            break

        rta_data = data[4:rta_len]

        increment = (rta_len + 4 - 1) &amp; ~(4 - 1)
        data = data[increment:]
        remaining -= increment

        # Hoorah, a link is up!
        if rta_type == IFLA_IFNAME:
            print "New link %s" % rta_data
</pre>
</div>
</div>
</li></ul>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">The ADDR Messages</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
set/unset the IP address on the network interface on the
system. It consists of the following message types:
</p>
<ol class="org-ol">
<li><code>RTM_NEWADDR</code>
</li>
<li><code>RTM_DELADDR</code>
</li>
<li><code>RTM_GETADDR</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">The ROUTE Messages</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
update the routing table. It consists of the following
message types:
</p>
<ol class="org-ol">
<li><code>RTM_NEWROUTE</code>
</li>
<li><code>RTM_DELROUTE</code>
</li>
<li><code>RTM_GETROUTE</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4">The QDISC Messages</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
add/delete the qdisc to the queuing discipline of the
system. It consists of the following message types:
</p>
<ol class="org-ol">
<li><code>RTM_NEWQDISC</code>
</li>
<li><code>RTM_DELQDISC</code>
</li>
<li><code>RTM_GETQDISC</code>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5">The CLASS Messages</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
add/delete a class to the qdisc of the queuing discipline of
the system. It consists of the following message types:
</p>
<ol class="org-ol">
<li>RTM<sub>NEWCLASS</sub>
</li>
<li>RTM<sub>DELCLASS</sub>
</li>
<li>RTM<sub>GETCLASS</sub>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6">The FILTER Messages</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
add/delete a fi lter to the class of qdisc of the queuing
discipline of the system. It consists of following message
types: 
</p>
<ol class="org-ol">
<li><code>RTM_NEWFILTER</code>
</li>
<li><code>RTM_DELFILTER</code>
</li>
<li><code>RTM_GETFILTER</code>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Socket Monitoring Interface</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<code>sock_diag</code> netlink提供了一个基于netlink的子系统用于获取socket的
相关信息。
</p>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">创建</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
在内核中，创建了一个类型为 <code>NETLINK_SOCK_DIAG</code> 的netlink
socket. 
</p>
<div class="org-src-container">

<pre class="src src-c">static int __net_init diag_net_init(struct net *net)
{
  struct netlink_kernel_cfg cfg = {
    .input = sock_diag_rcv,
  };
  net-&gt;diag_nlsk = netlink_kernel_create(net, NETLINK_SOCK_DIAG, &amp;cfg);
  return net-&gt;diag_nlsk == NULL ? -ENOMEM : 0;
}
(net/core/sock_diag.c)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">加入监控</h4>
<div class="outline-text-4" id="text-1-5-2">
<ol class="org-ol">
<li>定义一个 <code>sock_diag_handler</code> 
<div class="org-src-container">

<pre class="src src-c">static const struct sock_diag_handler unix_diag_handler = {
  .family = AF_UNIX,
  .dump = unix_diag_handler_dump,
};
</pre>
</div>
</li>
<li>注册该 <code>handler</code> 
<div class="org-src-container">

<pre class="src src-c">static int __init unix_diag_init(void)
{
  return sock_diag_register(&amp;unix_diag_handler);
}
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">总结</h3>
<div class="outline-text-3" id="text-1-6">
<p>
What happens in user space?
</p>

<ol class="org-ol">
<li>It creates a netlink socket and binds it to the address structure.
</li>
<li>It allocates the request message.
</li>
<li>It allocates a message structure msg.
</li>
<li>It calls system call sendmsg.
</li>
</ol>

<p>
What happens in kernel space?
</p>

<ol class="org-ol">
<li>The received msg structure and the necessary data structure
gets copied to kernel space by <code>copy_from_user</code> and verify iovec.
</li>
<li>It creates <code>sk_buff</code> and uses <code>memcpy_from_iovec</code> to copy the msg's
iovec to the data area of <code>sk_buff</code> .
</li>
<li>It searches the <code>nl_table</code> with the sock that has the same pid
as the current process.
</li>
<li>It enqueues the <code>sk_buff</code> in the socket ’ s receive queue and
then dequeues each <code>sk_buff</code> in the receive queue.
</li>
<li>It extracts the family and type from the <code>sk_buff</code> ; and based
on the family and type values, it checks the <code>rtnetlink_link</code>
table for calling the appropriate doit function, which takes
the appropriate actions. 
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">libnl编程实例</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">用户空间netlink的创建</h4>
<div class="outline-text-4" id="text-1-7-1">
<pre class="example">
fd = socket(AF_NETLINK, SOCK_RAW, protocol);
</pre>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">查询附近的AP列表</h4>
<div class="outline-text-4" id="text-1-7-2">
<ol class="org-ol">
<li>libnl 1.x兼容性代码
<div class="org-src-container">

<pre class="src src-c">#ifndef __COMMON_H__
#define __COMMON_H__

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;net/if.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdbool.h&gt;

#include &lt;ctype.h&gt;
#include &lt;netlink/attr.h&gt;

#include &lt;netlink/genl/genl.h&gt;
#include &lt;netlink/genl/family.h&gt;
#include &lt;netlink/genl/ctrl.h&gt;
#include &lt;netlink/msg.h&gt;
#include &lt;netlink/attr.h&gt;

#include "nl80211.h"
#include "ieee80211.h"

#define ETH_ALEN 6

#if !defined(CONFIG_LIBNL20) &amp;&amp; !defined(CONFIG_LIBNL30)

#define nl_sock nl_handle

static inline struct nl_handle *nl_socket_alloc(void)
{
  return nl_handle_alloc();
}

static inline void nl_socket_free(struct nl_sock *h)
{
  nl_handle_destroy(h);
}

static inline int nl_socket_set_buffer_size(struct nl_sock *sk,
                                            int rxbuf, int txbuf)
{
  return nl_set_buffer_size(sk, rxbuf, txbuf);
}
#endif /* CONFIG_LIBNL20 &amp;&amp; CONFIG_LIBNL30 */

struct nl80211_state {
  struct nl_sock *nl_sock;
  int nl80211_id; //family id
};

struct cmd {
  uint8_t cmd;
  int nl_flags; //netlink flags
  int (*handler)(struct nl80211_state *state,
                 struct nl_cb *cb,
                 struct nl_msg *msg);
};

static inline void mac_addr_n2a(char *mac_addr, unsigned char *arg)
{
  int i, l;

  l = 0;
  for (i = 0; i &lt; ETH_ALEN ; i++) {
    if (i == 0) {
      sprintf(mac_addr+l, "%02x", arg [i] );
      l += 2;
    } else {
      sprintf(mac_addr+l, ":%02x", arg [i] );
      l += 3;
    }
  }
}

static inline int mac_addr_a2n(unsigned char *mac_addr, char *arg)
{
  int i;

  for (i = 0; i &lt; ETH_ALEN ; i++) {
    int temp;
    char *cp = strchr(arg, ':');
    if (cp) {
      *cp = 0;
      cp++;
    }
    if (sscanf(arg, "%x", &amp;temp) != 1)
      return -1;
    if (temp &lt; 0 || temp &gt; 255)
      return -1;

    mac_addr_t[i] = temp;
    if (!cp)
      break;
    arg = cp;
  }
  if (i &lt; ETH_ALEN - 1)
    return -1;

  return 0;
}

#endif
</pre>
</div>
</li>

<li>获取family id信息
<div class="org-src-container">

<pre class="src src-c">#include "common.h"

int main(int argc, char *argv[])
{
  int err;
  struct nl_sock *sock = nl_socket_alloc();
  if (!sock) {
    fprintf(stderr, "Failed to allocate netlink socket.\n");
    return -ENOMEM;
  }
  nl_socket_set_buffer_size(sock, 8192, 8192);

  if (genl_connect(sock)) {
    fprintf(stderr, "Failed to connect to generic netlink.\n");
    err = -ENOLINK;
    goto out_handle_destroy;
  }

  int nl80211_id = genl_ctrl_resolve(sock, "nl80211");
  if (nl80211_id &lt; 0) {
    fprintf(stderr, "nl80211 not found.\n");
    err = -ENOENT;
    goto out_handle_destroy;
  }

  printf("NL802.11 family id: %d\n", nl80211_id);

  return 0;

 out_handle_destroy:
  nl_socket_free(sock);
  return err;
}
</pre>
</div>
</li>

<li>获取网卡设备的编号
<div class="org-src-container">

<pre class="src src-c">#include "common.h"

static int get_device_index1(char *name)
{
  char buf[200];
  int fd, pos;

  snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
  fd = open(buf, O_RDONLY);
  if (fd &lt; 0) {
    printf("文件打开失败！！！\n");
    return -1;
  }
  pos = read(fd, buf, sizeof(buf) - 1);
  if (pos &lt; 0) {
    printf("读取文件失败!!!\n");
    close(fd);
    return -1;
  }
  buf[pos] = '\0';
  close(fd);
  return atoi(buf);
}

static int get_device_index2(const char *ifname)
{
  unsigned int index = if_nametoindex(ifname);
  if (index == 0)
    index = -1;
  return index;
}

int main(int argc, char *argv[])
{
  printf(" Phy0 Index: %d\n", get_device_index1("phy0"));
  printf(" Device Index: %d\n", get_device_index2("wlan0"));
  return 0;
}
</pre>
</div>
</li>

<li>发送802.11命令
基本步骤
<ol class="org-ol">
<li>初始化NL80211
<div class="org-src-container">

<pre class="src src-c">#include "common.h"


int nl80211_init(struct nl80211_state *state)
{
  int err;

  state-&gt;nl_sock = nl_socket_alloc();
  if (!state-&gt;nl_sock) {
    fprintf(stderr, "Failed to allocate netlink socket.\n");
    return -ENOMEM;
  }

  nl_socket_set_buffer_size(state-&gt;nl_sock, 8192, 8192);

  if (genl_connect(state-&gt;nl_sock)) {
    fprintf(stderr, "Failed to connect to generic netlink.\n");
    err = -ENOLINK;
    goto out_handle_destroy;
  }

  state-&gt;nl80211_id = genl_ctrl_resolve(state-&gt;nl_sock, "nl80211");
  if (state-&gt;nl80211_id &lt; 0) {
    fprintf(stderr, "nl80211 not found.\n");
    err = -ENOENT;
    goto out_handle_destroy;
  }

  return 0;

 out_handle_destroy:
  nl_socket_free(state-&gt;nl_sock);
  return err;
}

void nl80211_cleanup(struct nl80211_state *state)
{
  nl_socket_free(state-&gt;nl_sock);
}
</pre>
</div>
</li>

<li>指定网络设备号
<div class="org-src-container">

<pre class="src src-c">static int get_device_index(const char *ifname)
{
  unsigned int index = if_nametoindex(ifname);
  if (index == 0)
    index = -1;
  return index;
}
</pre>
</div>
</li>

<li>发送消息
<div class="org-src-container">

<pre class="src src-c">static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,
                         void *arg)
{
  int *ret = arg;
  *ret = err-&gt;error;
  return NL_STOP;
}

static int finish_handler(struct nl_msg *msg, void *arg)
{
  int *ret = arg;
  *ret = 0;
  return NL_SKIP;
}

static int ack_handler(struct nl_msg *msg, void *arg)
{
  int *ret = arg;
  *ret = 0;
  return NL_STOP;
}

int send_command(struct nl80211_state *state, struct cmd *cmd)
{
  struct nl_cb *cb;
  struct nl_cb *s_cb;
  struct nl_msg *msg;
  int err;

  msg = nlmsg_alloc();
  if (!msg) {
    fprintf(stderr, "failed to allocate netlink message\n");
    return 2;
  }
#if _DEBUG
  cb = nl_cb_alloc(NL_CB_DEBUG);
  s_cb = nl_cb_alloc(NL_CB_DEBUG);
#else
  cb = nl_cb_alloc(NL_CB_DEFAULT);
  s_cb = nl_cb_alloc(NL_CB_DEFAULT);
#endif
  if (!cb || !s_cb) {
    fprintf(stderr, "failed to allocate netlink callbacks\n");
    err = 2;
    goto out_free_msg;
  }

  /*

    void* genlmsg_put(
    struct nl_msg * msg,
    uint32_t port,
    uint32_t seq,
    int family,
    int hdrlen,
    int flags,
    uint8_t cmd,
    uint8_t version 
    ) 
    Parameters
    msg Netlink message object
    port Netlink port or NL_AUTO_PORT
    seq Sequence number of message or NL_AUTO_SEQ
    family Numeric family identifier
    hdrlen Length of user header
    flags Additional Netlink message flags (optional)
    cmd Numeric command identifier
    version Interface version
  */
  genlmsg_put(msg, 0, 0, state-&gt;nl80211_id, 0,
              cmd-&gt;nl_flags, cmd-&gt;cmd, 0);


  NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, get_device_index("wlan0"));

  err = cmd-&gt;handler(state, cb, msg);
  if (err)
    goto out;

  nl_socket_set_cb(state-&gt;nl_sock, s_cb);
  err = nl_send_auto_complete(state-&gt;nl_sock, msg);
  if (err &lt; 0)
    goto out;

  err = 1;

  nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &amp;err);
  nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &amp;err);
  nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &amp;err);

  while (err &gt; 0) {
    nl_recvmsgs(state-&gt;nl_sock, cb);
  }

 out:
  nl_cb_put(cb);
 out_free_msg:
  nlmsg_free(msg);
  return err;
 nla_put_failure:
  fprintf(stderr, "building message failed\n");
  return 2;
}
</pre>
</div>
</li>

<li>扫描命令
<div class="org-src-container">

<pre class="src src-c">#include "common.h"
extern int nl80211_init(struct nl80211_state *state);
extern void nl80211_cleanup(struct nl80211_state *state);
extern int get_device_index(const char *);

static int prepare_scan_req(struct nl80211_state *state, struct nl_cb *cb, struct nl_msg *msg)
{
  struct nl_msg *ssids = NULL;
  struct nl_msg *freqs = NULL;

  int err = -ENOBUFS;
  int flags = 0;

  ssids = nlmsg_alloc();
  if (!ssids) {
    return -ENOMEM;
  }

  freqs = nlmsg_alloc();
  if (!freqs) {
    nlmsg_free(ssids);
    return -ENOMEM;
  }

  //Freq 5220 MHz
  NLA_PUT_U32(freqs, 0, 5220);
  //SSID
  //NLA_PUT(ssids, 1, strlen("MiBox_5G"), "MiBox_5G");
  NLA_PUT(ssids, 1, 0, "");

  //主动扫描
  nla_put_nested(msg, NL80211_ATTR_SCAN_SSIDS, ssids);

  //扫描指定的频率
  nla_put_nested(msg, NL80211_ATTR_SCAN_FREQUENCIES, freqs);

  //设置扫描标记
  flags |= NL80211_SCAN_FLAG_FLUSH;
  NLA_PUT_U32(msg, NL80211_ATTR_SCAN_FLAGS, flags);

  err = 0;

 nla_put_failure:
  nlmsg_free(ssids);
  nlmsg_free(freqs);
  return err;
}

static struct cmd scan_req = {
  .cmd = NL80211_CMD_TRIGGER_SCAN,
  .nl_flags = 0,
  .handler = prepare_scan_req,
};

static int print_bss_handler(struct nl_msg *msg, void *arg)
{
  struct nlattr *tb[NL80211_ATTR_MAX + 1];
  struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
  struct nlattr *bss[NL80211_BSS_MAX + 1];
  char mac_addr[20], dev[20];
  static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
    [NL80211_BSS_TSF] = { .type = NLA_U64 },
    [NL80211_BSS_FREQUENCY] = { .type = NLA_U32 },
    [NL80211_BSS_BSSID] = { },
    [NL80211_BSS_BEACON_INTERVAL] = { .type = NLA_U16 },
    [NL80211_BSS_CAPABILITY] = { .type = NLA_U16 },
    [NL80211_BSS_INFORMATION_ELEMENTS] = { },
    [NL80211_BSS_SIGNAL_MBM] = { .type = NLA_U32 },
    [NL80211_BSS_SIGNAL_UNSPEC] = { .type = NLA_U8 },
    [NL80211_BSS_STATUS] = { .type = NLA_U32 },
    [NL80211_BSS_SEEN_MS_AGO] = { .type = NLA_U32 },
    [NL80211_BSS_BEACON_IES] = { },
  };

  nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
            genlmsg_attrlen(gnlh, 0), NULL);

  if (!tb[NL80211_ATTR_BSS]) {
    fprintf(stderr, "bss info missing!\n");
    return NL_SKIP;
  }

  if (nla_parse_nested(bss, NL80211_BSS_MAX,
                       tb[NL80211_ATTR_BSS],
                       bss_policy)) {
    fprintf(stderr, "failed to parse nested attributes!\n");
    return NL_SKIP;
  }

  if (!bss[NL80211_BSS_BSSID])
    return NL_SKIP;

  mac_addr_n2a(mac_addr, nla_data(bss[NL80211_BSS_BSSID]));
  printf("BSS %s", mac_addr);
  if (tb[NL80211_ATTR_IFINDEX]) {
    if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
    printf("(on %s)", dev);
  }

  if (bss[NL80211_BSS_STATUS]) {
    switch (nla_get_u32(bss[NL80211_BSS_STATUS])) {
    case NL80211_BSS_STATUS_AUTHENTICATED:
      printf(" -- authenticated");
      break;
    case NL80211_BSS_STATUS_ASSOCIATED:
      printf(" -- associated");
      break;
    case NL80211_BSS_STATUS_IBSS_JOINED:
      printf(" -- joined");
      break;
    default:
      printf(" -- unknown status: %d",
             nla_get_u32(bss[NL80211_BSS_STATUS]));
      break;
    }
  }
  printf("\n");

  return NL_SKIP;
}

static int prepare_scan_result_req(struct nl80211_state *state, struct nl_cb *cb, struct nl_msg *msg)
{
  nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_bss_handler,
            NULL);
}

static struct cmd scan_result_req = {
  .cmd = NL80211_CMD_GET_SCAN,
  .nl_flags = 0,
  .handler = prepare_scan_result_req,
};

static void send_scan_request(struct nl80211_state *nlstate)
{
  send_command(nlstate, &amp;scan_req);
}

static void get_scan_results(struct nl80211_state *nlstate)
{
  send_command(nlstate, &amp;scan_result_req);
}

int main(int argc, char *argv[])
{
  struct nl80211_state nlstate;
  int err;

  err = nl80211_init(&amp;nlstate);
  if (err)
    return 1;

  send_scan_request(&amp;nlstate);
  get_scan_results(&amp;nlstate);
  nl80211_cleanup(&amp;nlstate);
  return err;
}
</pre>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">netlink要点记录</a>
<ul class="nav">
<li><a href="#sec-1-1">netlink与IOCTL的对比</a></li>
<li><a href="#sec-1-2">netlink家族</a>
<ul class="nav">
<li><a href="#sec-1-2-1">Netlink Socket库</a></li>
<li><a href="#sec-1-2-2"><code>sockaddr_nl</code> 结构</a></li>
<li><a href="#sec-1-2-3">Kernel Netlink Socket</a></li>
<li><a href="#sec-1-2-4">注册一个 <code>netlink socket</code></a></li>
<li><a href="#sec-1-2-5">发送一个 <code>netlink socket</code> 消息</a></li>
<li><a href="#sec-1-2-6">Netlink的消息格式</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Generic Netlink协议</a>
<ul class="nav">
<li><a href="#sec-1-3-1">Generic Netlink Family</a></li>
<li><a href="#sec-1-3-2">创建和发送 <code>Generic Netlink消息</code></a></li>
<li><a href="#sec-1-3-3">libnl-genl库</a></li>
<li><a href="#sec-1-3-4">使用建议</a></li>
</ul>
</li>
<li><a href="#sec-1-4">ROUTE netlink</a>
<ul class="nav">
<li><a href="#sec-1-4-1">LINK Parameter Messages</a></li>
<li><a href="#sec-1-4-2">The ADDR Messages</a></li>
<li><a href="#sec-1-4-3">The ROUTE Messages</a></li>
<li><a href="#sec-1-4-4">The QDISC Messages</a></li>
<li><a href="#sec-1-4-5">The CLASS Messages</a></li>
<li><a href="#sec-1-4-6">The FILTER Messages</a></li>
</ul>
</li>
<li><a href="#sec-1-5">Socket Monitoring Interface</a>
<ul class="nav">
<li><a href="#sec-1-5-1">创建</a></li>
<li><a href="#sec-1-5-2">加入监控</a></li>
</ul>
</li>
<li><a href="#sec-1-6">总结</a></li>
<li><a href="#sec-1-7">libnl编程实例</a>
<ul class="nav">
<li><a href="#sec-1-7-1">用户空间netlink的创建</a></li>
<li><a href="#sec-1-7-2">查询附近的AP列表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</div></div></div>
