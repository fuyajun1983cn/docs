--- 
layout: default
---
<div class="header">
  <div class="jumbotron">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>设计模式快速参考</h1>
          <p>简要描述了软件设计中常用的一些设计模式，并给出了简单的示例代码。</p>
        </div>
      </div>
    </div>
  </div>
</div>


<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">设计模式快速参考</h1>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">构造模式</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://www.java2s.com/Tutorials/Java/Java_Design_Patterns/index.htm">http://www.java2s.com/Tutorials/Java/Java_Design_Patterns/index.htm</a>
主要描述如何更好地表述一个对象。主要有如下一些具体模式：
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">抽象工厂(Abstract Factory)</h3>
<div class="outline-text-3" id="text-1-1">
<p>
抽象工厂也称为工厂的工厂，它创建其他的工厂。使用抽象工厂时，先创建
一个超级工厂，通过这个超级工厂，创建其他的工厂类，利用这些工厂类创
建对象。
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">情景示例</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
假设创建一些形状和打印机两类对象，对于形状类型，我们有圆，长方形和正
方形，对于打印机类型，我们有纸质打印机，网络打印机以及屏幕打印机。
对于形状类型，接口定义如下：
</p>
<div class="org-src-container">

<pre class="src src-java">interface Shape {
    void draw();
}
</pre>
</div>

<p>
接下来创建一些具体的形状类：
</p>
<div class="org-src-container">

<pre class="src src-java">class Rectangle implements Shape {

    @Override
    public void draw() {
        System.out.println("Inside Rectangle::draw() method.");
    }
}
class Square implements Shape {

    @Override
    public void draw() {
        System.out.println("Inside Square::draw() method.");
    }
}
class Circle implements Shape {

    @Override
    public void draw() {
        System.out.println("Inside Circle::draw() method.");
    }
}
</pre>
</div>

<p>
然后创建打印机接口
</p>
<div class="org-src-container">

<pre class="src src-java">interface Printer{
   void print();
}
</pre>
</div>

<p>
接着创建一些具体的打印机类
</p>
<div class="org-src-container">

<pre class="src src-java">class PaperPrinter implements Printer {
    @Override
    public void print() {
        System.out.println("Papter");
    }
}

class WebPrinter implements Printer {
    @Override
    public void print() {
        System.out.println("Web");
    }
}

class ScreenPrinter implements Printer {
    @Override
    public void print() {
        System.out.println("Screen");
    }
}
</pre>
</div>

<p>
最后创建一个抽象类来获取创建形状和打印机对象的工厂类
</p>
<div class="org-src-container">

<pre class="src src-java">abstract class AbstractFactory {
   abstract Printer getPrinter(String type);
   abstract Shape getShape(String shape) ;
}
</pre>
</div>

<p>
最后，我们创建一些具体的工厂类来创建对应的对象
</p>
<div class="org-src-container">

<pre class="src src-java">class ShapeFactory extends AbstractFactory {

    @Override
    public Shape getShape(String shapeType){
        if(shapeType == null){
            return null;
        }    
        if(shapeType.equalsIgnoreCase("CIRCLE")){
            return new Circle();
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle();
        } else if(shapeType.equalsIgnoreCase("SQUARE")){
            return new Square();
        }
        return null;
    }

    @Override
    Printer getPrinter(String type) {
        return null;
    }
}
class PrinterFactory extends AbstractFactory {

    @Override
    public Shape getShape(String shapeType){
        return null;
    }

    @Override
    Printer getPrinter(String type) {
        if(type == null){
            return null;
        }    
        if(type.equalsIgnoreCase("paper")){
            return new PaperPrinter();
        } else if(type.equalsIgnoreCase("web")){
            return new WebPrinter();
        } else if(type.equalsIgnoreCase("Screen")){
            return new ScreenPrinter();
        }
        return null;
    }
}
</pre>
</div>

<p>
最后，创建一个工厂的产生类，通过不同的参数返回不同的工厂类：
</p>
<div class="org-src-container">

<pre class="src src-java">class FactoryProducer {
    public static AbstractFactory getFactory(String choice){
        if(choice.equalsIgnoreCase("SHAPE")){
            return new ShapeFactory();
        } else if(choice.equalsIgnoreCase("Printer")){
            return new PrinterFactory();
        }
        return null;
    }
}
</pre>
</div>

<p>
下面代码显示的如何使用抽象工厂类来创建不同的对象：
</p>
<div class="org-src-container">

<pre class="src src-java">public class Main {
    public static void main(String[] args) {

        //get shape factory
        AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");

        //get an object of Shape Circle
        Shape shape1 = shapeFactory.getShape("CIRCLE");

        //call draw method of Shape Circle
        shape1.draw();

        //get an object of Shape Rectangle
        Shape shape2 = shapeFactory.getShape("RECTANGLE");

        //call draw method of Shape Rectangle
        shape2.draw();

        //get an object of Shape Square 
        Shape shape3 = shapeFactory.getShape("SQUARE");

        //call draw method of Shape Square
        shape3.draw();

        //get printer factory
        AbstractFactory printerFactory = FactoryProducer.getFactory("printer");

        Printer printer1 = printerFactory.getPrinter("Paper");
        printer1.print();
        Printer printer2 = printerFactory.getPrinter("Web");
        printer2.print();
        Printer printer3 = printerFactory.getPrinter("Screen");
        printer3.print();
    }
}
</pre>
</div>

<p>
总体的类结果如下：
</p>

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016081330.png" class="img-responsive" alt="2016081330.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">构造器(Builder)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
构造器模式是使用一些简单的对象去创建一个更复杂的对象。它一步步地
从小而简单的对象中创建更大的对象。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">情景分析</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
例如，当我们创建一个应用程序的主窗体时，我们需要创建一个菜单，
一个工具栏，然后将它们加入到主窗体中。
</p>

<p>
对于每个窗体，我们需要创建一个空的窗体，创建一个菜单，工具栏，
并将菜单、工具栏安装到窗体中。
</p>

<div class="org-src-container">

<pre class="src src-java">class Menu {
}
class ToolBar {
}
class MainWindow {
    Menu menu;
    ToolBar toolBar;
    public Menu getMenu() {
        return menu;
    }
    public void setMenu(Menu menu) {
        this.menu = menu;
    }
    public ToolBar getToolBar() {
        return toolBar;
    }
    public void setToolBar(ToolBar toolBar) {
        this.toolBar = toolBar;
    }
}
class WindowBuilder{
    public static MainWindow createWindow(){
        MainWindow window = new MainWindow();
        Menu menu = new Menu();
        ToolBar toolBar = new ToolBar();
        window.setMenu(menu);
        window.setToolBar(toolBar);
        return window;
    }
}
public class Main {
    public static void main(String[] args) {
        MainWindow object = WindowBuilder.createWindow();

    }
}
</pre>
</div>

<p>
类关系图如下：
</p>
<div class="org-src-container">

<pre class="src src-plantuml">@startuml
package "Component Objects" {
        class Menu
        class ToolBar
}

class MainWindow {
      Menu menu
     ToolBar toolBar

     +Menu getMenu()
     +void setMenu(Menu menu)
     +ToolBar getToolBar()
     +void setToolBar(ToolBar toolBar)
}

MainWindow o-- Menu
MainWindow o-- ToolBar

class WindowBuilder {
      static MainWindow createWindow()
}

WindowBuilder -- MainWindow

class Main

Main --&gt; WindowBuilder: &lt;&lt;use&gt;&gt;

@enduml
</pre>
</div>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016082901.png" class="img-responsive" alt="2016082901.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">工厂方法(Factory Method)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
defines an abstract class that creates objects but lets each
subclass decide which object to create. 
</p>

<p>
定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一
个类的实例化延迟到其子类。
</p>

<p>
工厂方法将使用者隐藏了对象创建的逻辑。
</p>
</div>


<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">情景分析</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
定义Shape接口：
</p>
<div class="org-src-container">

<pre class="src src-java">public interface Shape {
   void draw();
}
</pre>
</div>

<p>
定义Rectangle类：
</p>
<div class="org-src-container">

<pre class="src src-java">public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
</pre>
</div>

<p>
定义Square类：
</p>
<div class="org-src-container">

<pre class="src src-java">public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
</pre>
</div>

<p>
定义Circle类：
</p>
<div class="org-src-container">

<pre class="src src-java">public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
</pre>
</div>

<p>
定义ShapeFactory类：
</p>
<div class="org-src-container">

<pre class="src src-java">public class ShapeFactory {

   //use getShape method to get object of type shape 
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }    
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
</pre>
</div>

<p>
下面是使用工厂类的示例：
</p>
<div class="org-src-container">

<pre class="src src-java">public class Main {

   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //get an object of Circle and call its draw method.
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //call draw method of Circle
      shape1.draw();

      //get an object of Rectangle and call its draw method.
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //call draw method of Rectangle
      shape2.draw();

      //get an object of Square and call its draw method.
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //call draw method of circle
      shape3.draw();
   }
}
</pre>
</div>

<p>
类图
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016051801.png" class="img-responsive" alt="2016051801.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">原型(Prototype)</h3>
<div class="outline-text-3" id="text-1-4">
<p>
原型模式拥有较好的性能去复制对象。
</p>

<p>
在原型模式中，一般返回对象的拷贝而不是重新创建一个新的对象。
</p>

<p>
如果创建一个新的对象代价很多，特别是涉及到递归时，会考虑使用原型
模式。
</p>
</div>


<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">情景分析</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
创建抽象类：
</p>
<div class="org-src-container">

<pre class="src src-java">abstract class Shape implements Cloneable {

   private String id;
   protected String type;

   abstract void draw();

   public String getType(){
      return type;
   }

   public String getId() {
      return id;
   }

   public void setId(String id) {
      this.id = id;
   }

   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
</pre>
</div>

<p>
创建三个具体子类：
</p>
<div class="org-src-container">

<pre class="src src-java">class Rectangle extends Shape {

   public Rectangle(){
     type = "Rectangle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
class Square extends Shape {

   public Square(){
     type = "Square";
   }

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
class Circle extends Shape {

   public Circle(){
     type = "Circle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
</pre>
</div>

<p>
创建ShapeProtoType ，它返回不同shape子类的原型：
</p>
<div class="org-src-container">

<pre class="src src-java">class ShapeProtoType{
  /*w w w .  j a va  2  s. co  m*/
   private static Hashtable&lt;String, Shape&gt; shapeMap 
      = new Hashtable&lt;String, Shape&gt;();

   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId("1");
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId("2");
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId("3");
      shapeMap.put(rectangle.getId(),rectangle);
   }
}
public class Main{
   public static void main(String[] args) {
      ShapeProtoType.loadCache();

      Shape clonedShape = (Shape) ShapeProtoType.getShape("1");
      System.out.println("Shape : " + clonedShape.getType());    

      Shape clonedShape2 = (Shape) ShapeProtoType.getShape("2");
      System.out.println("Shape : " + clonedShape2.getType());    

      Shape clonedShape3 = (Shape) ShapeProtoType.getShape("3");
      System.out.println("Shape : " + clonedShape3.getType());    
   }
}
</pre>
</div>

<p>
类关系图：
</p>

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016082902.png" class="img-responsive" alt="2016082902.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">单例(Singleton)</h3>
<div class="outline-text-3" id="text-1-5">
<p>
单例 模式涉及一个类，主要是为了保持这个类的对象任何时候只能有一
个实例存在。
</p>
</div>


<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">情景分析</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">

<pre class="src src-java">class MainWindow {
   //create an object of MainWindow
   private static MainWindow instance = new MainWindow();

   //make the constructor private so that this class cannot be
   //instantiated by other class
   private MainWindow(){}

   //Get the only object available
   public static MainWindow getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println("Hello World!");
   }
}

public class Main {
   public static void main(String[] args) {
      //Get the only object available
      MainWindow object = MainWindow.getInstance();

      //show the message
      object.showMessage();
   }
}
</pre>
</div>

<p>
示例图：
</p>

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016082903.png" class="img-responsive" alt="2016082903.png">
</p>
</figure>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">结构模式</h2>
<div class="outline-text-2" id="text-2">
<p>
主要描述组织对象和类以完成更大的目标。主要有如下一些具体模式：
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">适配器(Adapter)</h3>
<div class="outline-text-3" id="text-2-1">
<p>
适配器是两个不兼容的实体之间的转换器，适配器模式是一种结构型模式，
它做为两个不兼容的接口之间的桥梁。通过适配器，我们可以将两个不兼容
的接口统一起来。
</p>
</div>


<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">情景分析</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
创建一个播放任何媒体文件的Player接口， MyPlayer是适配器，它统一了
播放媒体文件的各种接口。
</p>

<div class="org-src-container">

<pre class="src src-java">interface Player {
    public void play(String type, String fileName);
}/*from  w  w  w .j a v  a2s .  c o m*/
interface AudioPlayer {  
    public void playAudio(String fileName);
}
interface VideoPlayer {  
    public void playVideo(String fileName);
}
class MyAudioPlayer implements AudioPlayer {
    @Override
    public void playAudio(String fileName) {
        System.out.println("Playing. Name: "+ fileName);    
    }
}
class MyVideoPlayer implements VideoPlayer {
    @Override
    public void playVideo(String fileName) {
        System.out.println("Playing. Name: "+ fileName);    
    }
}

class MyPlayer implements Player {

    AudioPlayer audioPlayer = new MyAudioPlayer();
    VideoPlayer videoPlayer = new MyVideoPlayer();

    public MyPlayer(){      
    }
    @Override
    public void play(String audioType, String fileName) {
        if(audioType.equalsIgnoreCase("avi")){
            videoPlayer.playVideo(fileName);
        }else if(audioType.equalsIgnoreCase("mp3")){
            audioPlayer.playAudio(fileName);
        }
    }
}
public class Main{
    public static void main(String[] args) {
        MyPlayer myPlayer = new MyPlayer();

        myPlayer.play("mp3", "h.mp3");
        myPlayer.play("avi", "me.avi");
    }
}
</pre>
</div>

<p>
示例图：
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016091001.png" class="img-responsive" alt="2016091001.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">桥接(Bridge)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
桥接模式将定义与其实现分开，在该模式中，有一个接口充当桥接的角色，
桥接使得具体类与接口实现类之间相互独立。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">情景分析</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-java">interface Printer {
   public void print(int radius, int x, int y);
}/*www  .ja v  a  2s  . com*/
class ColorPrinter implements Printer {
   @Override
   public void print(int radius, int x, int y) {
      System.out.println("Color: " + radius +", x: " +x+", "+ y +"]");
   }
}
class BlackPrinter implements Printer {
   @Override
   public void print(int radius, int x, int y) {
      System.out.println("Black: " + radius +", x: " +x+", "+ y +"]");
   }
}
abstract class Shape {
   protected Printer print;
   protected Shape(Printer p){
      this.print = p;
   }
   public abstract void draw();  
}
class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, Printer draw) {
      super(draw);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }

   public void draw() {
      print.print(radius,x,y);
   }
}
public class Main {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new ColorPrinter());
      Shape blackCircle = new Circle(100,100, 10, new BlackPrinter());

      redCircle.draw();
      blackCircle.draw();
   }
}
</pre>
</div>

<p>
示例图：
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016091002.png" class="img-responsive" alt="2016091002.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">组合(Composite)</h3>
<div class="outline-text-3" id="text-2-3">
<p>
组合模式会创建一种树型结构来代表一组对象，并对一组对象视为单个对象，
使用一个类来代表一个树型结构。
</p>
</div>


<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">情景分析</h4>
<div class="outline-text-4" id="text-2-3-1">
<div class="org-src-container">

<pre class="src src-java">import java.util.ArrayList;
import java.util.List;
//from w w w .j  av  a  2 s  .  com
class Employee {
   private String name;
   private String title;
   private List&lt;Employee&gt; subordinates;

   public Employee(String name,String title) {
      this.name = name;
      this.title = title;
      subordinates = new ArrayList&lt;Employee&gt;();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List&lt;Employee&gt; getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return "Employee :[ Name : "+ name 
      +", dept : "+ title +subordinates +" ]";
   }   
}

public class Main {
   public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO");

      Employee headSales = new Employee("Rob","Sales");

      Employee headMarketing = new Employee("Mike","Marketing");

      Employee programmer1 = new Employee("Lili","Programmer");
      Employee programmer2 = new Employee("Bob","Programmer");

      Employee tester1 = new Employee("Jack","Tester");
      Employee tester2 = new Employee("Tom","Tester");

      CEO.add(headSales);
      CEO.add(headMarketing);

      headSales.add(tester1);
      headSales.add(tester2);

      headMarketing.add(programmer1);
      headMarketing.add(programmer2);

      //print all employees of the organization
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }    
   }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">修饰器(Decorator)</h3>
<div class="outline-text-3" id="text-2-4">
<p>
修饰器模式在不改变原有类型的基础上增加新的功能，它充当一种包装器，
对现有的类进行功能扩展。
</p>
</div>


<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">情景分析</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">

<pre class="src src-java">interface Printer {
   void print();//from w  w  w  .j  a  v a2 s .  co  m
}
class PaperPrinter implements Printer {
   @Override
   public void print() {
      System.out.println("Paper Printer");
   }
}
class PlasticPrinter implements Printer {
   @Override
   public void print() {
      System.out.println("Plastic Printer");
   }
}
abstract class PrinterDecorator implements Printer {
   protected Printer decoratedPrinter;
   public PrinterDecorator(Printer d){
      this.decoratedPrinter = d;
   }
   public void print(){
      decoratedPrinter.print();
   }  
}
class Printer3D extends PrinterDecorator {
   public Printer3D(Printer decoratedShape) {
      super(decoratedShape);    
   }
   @Override
   public void print() {
     System.out.println("3D.");
     decoratedPrinter.print();         
   }
}
public class Main {
   public static void main(String[] args) {
      Printer plasticPrinter = new PlasticPrinter();
      Printer plastic3DPrinter = new Printer3D(new PlasticPrinter());
      Printer paper3DPrinter = new Printer3D(new PaperPrinter());
      plasticPrinter.print();
      plastic3DPrinter.print();
      paper3DPrinter.print();
   }
}
</pre>
</div>

<p>
示例图：
</p>


<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016091003.png" class="img-responsive" alt="2016091003.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">门面(Facade)</h3>
<div class="outline-text-3" id="text-2-5">
<p>
门面模式隐藏了一个系统的复杂性，为使用者提供了一个简单的接口来与系
统交互。
</p>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">情景分析</h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">

<pre class="src src-java">class ShapeFacade {
  interface Shape {
    void draw();//from   ww  w .  ja  v a  2s .co  m
  }
  class Rectangle implements Shape {
    @Override
    public void draw() {
      System.out.println("Rectangle::draw()");
    }
  }
  class Square implements Shape {
    @Override
    public void draw() {
      System.out.println("Square::draw()");
    }
  }
  class Circle implements Shape {
    @Override
    public void draw() {
      System.out.println("Circle::draw()");
    }
  }
  private Shape circle = new Circle();
  private Shape rectangle = new Rectangle();
  private Shape square = new Square();

  public ShapeFacade() {
  }
  public void drawCircle() {
    circle.draw();
  }
  public void drawRectangle() {
    rectangle.draw();
  }
  public void drawSquare() {
    square.draw();
  }
}
public class Main {
  public static void main(String[] args) {
    ShapeFacade shapeFacade = new ShapeFacade();
    shapeFacade.drawCircle();
    shapeFacade.drawRectangle();
    shapeFacade.drawSquare();
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">享元(Flyweight)</h3>
<div class="outline-text-3" id="text-2-6">
<p>
使用共享来支持有效地支持大量细粒度的对象。
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">代理(Proxy)</h3>
<div class="outline-text-3" id="text-2-7">
<p>
在代理模式中，一个类代表另一个类的功能。在代理模式中，我们使用原始
的接口创建一个对象将功能暴露给外面世界。
</p>
</div>

<div id="outline-container-sec-2-7-1" class="outline-4">
<h4 id="sec-2-7-1">情景分析</h4>
<div class="outline-text-4" id="text-2-7-1">
<div class="org-src-container">

<pre class="src src-java">interface Printer {
   void print();/*ww  w  .  ja  v a 2  s  .  c  o  m*/
}
class ConsolePrinter implements Printer {
   private String fileName;

   public ConsolePrinter(String fileName){
      this.fileName = fileName;
   }
   @Override
   public void print() {
      System.out.println("Displaying " + fileName);
   }
}
class ProxyPrinter implements Printer{
   private ConsolePrinter consolePrinter;
   private String fileName;

   public ProxyPrinter(String fileName){
      this.fileName = fileName;
   }

   @Override
   public void print() {
      if(consolePrinter == null){
         consolePrinter = new ConsolePrinter(fileName);
      }
      consolePrinter.print();
   }
}
public class Main {

   public static void main(String[] args) {
      Printer image = new ProxyPrinter("test");
      image.print();   
   }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">过滤器(Filter/Criteria Pattern)</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Filter pattern filters objects using different criteria.
The criteria can be chained together through logical operations.
</p>
</div>

<div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">情景分析</h4>
<div class="outline-text-4" id="text-2-8-1">
<div class="org-src-container">

<pre class="src src-java">import java.util.List;
import java.util.ArrayList;
/*  w w  w.  j  a v  a2  s  .c  om*/
class Employee {
  private String name;
  private String gender;
  private String retireStatus;

  public Employee(String name, String gender, String r) {
    this.name = name;
    this.gender = gender;
    this.retireStatus = r;
  }

  public String getName() {
    return name;
  }

  public String getGender() {
    return gender;
  }

  public String getRetireStatus() {
    return retireStatus;
  }

  @Override
  public String toString() {
    return "Employee [name=" + name + ", gender=" + gender
        + ", retireStatus=" + retireStatus + "]";
  }
}

interface Criteria {
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons);
}

class CriteriaMale implements Criteria {

  @Override
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons) {
    List&lt;Employee&gt; malePersons = new ArrayList&lt;Employee&gt;();
    for (Employee person : persons) {
      if (person.getGender().equalsIgnoreCase("MALE")) {
        malePersons.add(person);
      }
    }
    return malePersons;
  }
}

class CriteriaFemale implements Criteria {

  @Override
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons) {
    List&lt;Employee&gt; femalePersons = new ArrayList&lt;Employee&gt;();
    for (Employee person : persons) {
      if (person.getGender().equalsIgnoreCase("FEMALE")) {
        femalePersons.add(person);
      }
    }
    return femalePersons;
  }
}

class CriteriaRetire implements Criteria {

  @Override
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons) {
    List&lt;Employee&gt; singlePersons = new ArrayList&lt;Employee&gt;();
    for (Employee person : persons) {
      if (person.getRetireStatus().equalsIgnoreCase("YES")) {
        singlePersons.add(person);
      }
    }
    return singlePersons;
  }
}

class AndCriteria implements Criteria {

  private Criteria criteria;
  private Criteria otherCriteria;

  public AndCriteria(Criteria criteria, Criteria otherCriteria) {
    this.criteria = criteria;
    this.otherCriteria = otherCriteria;
  }

  @Override
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons) {
    List&lt;Employee&gt; firstCriteriaPersons = criteria.meetCriteria(persons);
    return otherCriteria.meetCriteria(firstCriteriaPersons);
  }
}

class OrCriteria implements Criteria {

  private Criteria criteria;
  private Criteria otherCriteria;

  public OrCriteria(Criteria criteria, Criteria otherCriteria) {
    this.criteria = criteria;
    this.otherCriteria = otherCriteria;
  }

  @Override
  public List&lt;Employee&gt; meetCriteria(List&lt;Employee&gt; persons) {
    List&lt;Employee&gt; firstCriteriaItems = criteria.meetCriteria(persons);
    List&lt;Employee&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);

    for (Employee person : otherCriteriaItems) {
      if (!firstCriteriaItems.contains(person)) {
        firstCriteriaItems.add(person);
      }
    }
    return firstCriteriaItems;
  }
}

public class Main {
  public static void main(String[] args) {
    List&lt;Employee&gt; persons = new ArrayList&lt;Employee&gt;();

    persons.add(new Employee("Tom", "Male", "YES"));
    persons.add(new Employee("Jack", "Male", "NO"));
    persons.add(new Employee("Jane", "Female", "NO"));
    persons.add(new Employee("Diana", "Female", "YES"));
    persons.add(new Employee("Mike", "Male", "NO"));
    persons.add(new Employee("Bob", "Male", "YES"));

    Criteria male = new CriteriaMale();
    Criteria female = new CriteriaFemale();
    Criteria retire = new CriteriaRetire();
    Criteria retireMale = new AndCriteria(retire, male);
    Criteria retireOrFemale = new OrCriteria(retire, female);

    System.out.println("Males: ");
    printPersons(male.meetCriteria(persons));

    System.out.println("Females: ");
    printPersons(female.meetCriteria(persons));

    System.out.println("Retire Males: ");
    printPersons(retireMale.meetCriteria(persons));

    System.out.println("Retire Or Females: ");
    printPersons(retireOrFemale.meetCriteria(persons));
  }

  public static void printPersons(List&lt;Employee&gt; persons) {
    for (Employee person : persons) {
      System.out.println(person);
    }
  }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">行为模式</h2>
<div class="outline-text-2" id="text-3">
<p>
主要关注对象之间的交互。主要有如下一些具体模式：
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">责任链(Chain of Responsibility)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
责任链模式为一个请求创建了一系列的接收者对象。通常在使用这种模式时，
每个接收者包含对另一个接收者的引用，形成一个引用链。 如果某个对象
不能使用当前请求，它可以交给下一个接收者去使用。 
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">情景分析</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">

<pre class="src src-java">abstract class Logger {
   protected Logger nextLogger;
/* w w w.  j  av  a2 s .  c  om*/
   public void setNextLogger(Logger nextLogger){
      this.nextLogger = nextLogger;
   }

   public void logMessage(String message){
      log(message);
      if(nextLogger !=null){
         nextLogger.logMessage(message);
      }
   }
   abstract protected void log(String message);  
}

class ConsoleLogger extends Logger {
   public ConsoleLogger(){
   }
   @Override
   protected void log(String message) {    
      System.out.println("Console::Logger: " + message);
   }
}
class EMailLogger extends Logger {
   public EMailLogger(){
   }
   @Override
   protected void log(String message) {    
      System.out.println("EMail::Logger: " + message);
   }
}
class FileLogger extends Logger {
   public FileLogger(){
   }
   @Override
   protected void log(String message) {    
      System.out.println("File::Logger: " + message);
   }
}
public class Main {  
   private static Logger getChainOfLoggers(){
      Logger emailLogger = new EMailLogger();
      Logger fileLogger = new FileLogger();
      Logger consoleLogger = new ConsoleLogger();
      emailLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);
      return emailLogger;  
   }
   public static void main(String[] args) {
      Logger loggerChain = getChainOfLoggers();
      loggerChain.logMessage("Null pointer");
      loggerChain.logMessage("Array Index Out of Bound");
      loggerChain.logMessage("Illegal Parameters");
   }
}
</pre>
</div>

<figure>
<p><img src="http://blog.ifjy.me/images/2016/2016092710.png" class="img-responsive" alt="2016092710.png">
</p>
</figure>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">命令(Command)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
命令模式是一种数据驱动的模式，请求被封装成一个命令对象，传递给调
用者，调用者将相应的命令传递给相应的对象去执行。
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">情景分析</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-java">import java.util.ArrayList;
import java.util.List;
//ww w . j av  a2  s .  c o  m
interface Command {
  void execute();
}

class MouseCursor {
  private int x = 10;
  private int y = 10;
  public void move() {
    System.out.println("Old Position:"+x +":"+y);
    x++;
    y++;
    System.out.println("New Position:"+x +":"+y);

  }

  public void reset() {
    System.out.println("reset");
    x = 10;
    y = 10;
  }
}

class MoveCursor implements Command {
  private MouseCursor abcStock;

  public MoveCursor(MouseCursor abcStock) {
    this.abcStock = abcStock;
  }

  public void execute() {
    abcStock.move();
  }
}

class ResetCursor implements Command {
  private MouseCursor abcStock;

  public ResetCursor(MouseCursor abcStock) {
    this.abcStock = abcStock;
  }

  public void execute() {
    abcStock.reset();
  }
}

class MouseCommands {
  private List&lt;Command&gt; orderList = new ArrayList&lt;Command&gt;();

  public void takeOrder(Command order) {
    orderList.add(order);
  }

  public void placeOrders() {
    for (Command order : orderList) {
      order.execute();
    }
    orderList.clear();
  }
}

public class Main {
  public static void main(String[] args) {
    MouseCursor cursor = new MouseCursor();

    MoveCursor moveCursor = new MoveCursor(cursor);
    ResetCursor resetCursor = new ResetCursor(cursor);

    MouseCommands commands= new MouseCommands();
    commands.takeOrder(moveCursor);
    commands.takeOrder(resetCursor);

    commands.placeOrders();
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">解释器(Interpreter)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
通常解析器模式用于解析语言或表达式。
</p>
<div class="org-src-container">

<pre class="src src-java">interface Expression {
  public boolean evaluate(String context);
}/*from  ww w  .ja v  a  2 s  .  com*/

class IsInExpression implements Expression {
  private String data;

  public IsInExpression(String data) {
    this.data = data;
  }

  @Override
  public boolean evaluate(String context) {
    if (context.contains(data)) {
      return true;
    }
    return false;
  }
}

class OrExpression implements Expression {

  private Expression expr1 = null;
  private Expression expr2 = null;

  public OrExpression(Expression expr1, Expression expr2) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean evaluate(String context) {
    return expr1.evaluate(context) || expr2.evaluate(context);
  }
}

class AndExpression implements Expression {

  private Expression expr1 = null;
  private Expression expr2 = null;

  public AndExpression(Expression expr1, Expression expr2) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean evaluate(String context) {
    return expr1.evaluate(context) &amp;&amp; expr2.evaluate(context);
  }
}

public class Main {

  public static void main(String[] args) {
    Expression select = new IsInExpression("Select");
    Expression from = new IsInExpression("From");
    Expression isSelectFrom = new AndExpression(select, from);

    Expression insert = new IsInExpression("Insert");
    Expression update = new IsInExpression("Update");
    Expression isInsertOrUpdate = new OrExpression(insert, update);

    System.out.println(isSelectFrom.evaluate("Select"));
    System.out.println(isInsertOrUpdate.evaluate("Insert"));

    System.out.println(isSelectFrom.evaluate("Select From"));
    System.out.println(isInsertOrUpdate.evaluate("Update"));
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">迭代器(Iterator)</h3>
<div class="outline-text-3" id="text-3-4">
<p>
在不了解对象底层细节的情况下，按顺序访问一组对象。
</p>
<div class="org-src-container">

<pre class="src src-java">interface Iterator {
   public boolean hasNext();
   public Object next();
}/*  www  . ja v  a 2 s . c  o  m*/
class LetterBag {
   public String names[] = {"R" , "J" ,"A" , "L"};
   public Iterator getIterator() {
      return new NameIterator();
   }
   class NameIterator implements Iterator {
      int index;
      @Override
      public boolean hasNext() {
         if(index &lt; names.length){
            return true;
         }
         return false;
      }
      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }    
   }
}
public class Main {
   public static void main(String[] args) {
      LetterBag bag = new LetterBag();
      for(Iterator iter = bag.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }   
   }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">仲裁者(Mediator)</h3>
<div class="outline-text-3" id="text-3-5">
<p>
这个模式降低了多个对象间的通信。该模式提供了一个仲裁类处理不同对
象间的所有通信。
</p>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">情景分析</h4>
<div class="outline-text-4" id="text-3-5-1">
<div class="org-src-container">

<pre class="src src-java">class Printer {/*w w  w  .jav a2  s  . c  om*/
   public static void showMessage(Machine user, String message){
      System.out.println(new java.util.Date().toString()
         + " [" + user.getName() +"] : " + message);
   }
}
class Machine {
   private String name;

   public Machine(String name){
      this.name  = name;
   }
   public String getName() {
      return name;
   }
   public void setName(String name) {
      this.name = name;
   }
   public void sendMessage(String message){
      Printer.showMessage(this,message);
   }
}
class Main {
   public static void main(String[] args) {
      Machine m1= new Machine("M1");
      Machine m2 = new Machine("M2");

      m1.sendMessage("Rebooting");
      m2.sendMessage("Computing");
   }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">备忘录(Memento)</h3>
<div class="outline-text-3" id="text-3-6">
<p>
The memento pattern is a software design pattern that provides
the ability to restore an object to its previous state (undo via
rollback). 
</p>

<p>
备忘录模式有三个对象： Originator, Caretaker, memento。
Originator是拥有内部状态的一些对象， Caretaker首先向Originator要
一个memento对象，然后执行一系列它想执行的对象。为了回退到执行操作
之前的状态，它返回一个memento对象。
</p>
</div>
<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">情景分析</h4>
<div class="outline-text-4" id="text-3-6-1">
<div class="org-src-container">

<pre class="src src-java">import java.util.List;
import java.util.ArrayList;
class Originator {
    private String state;
    // The class could also contain additional data that is not part of the
    // state saved in the memento..

    public void set(String state) {
        System.out.println("Originator: Setting state to " + state);
        this.state = state;
    }

    public Memento saveToMemento() {
        System.out.println("Originator: Saving to Memento.");
        return new Memento(this.state);
    }

    public void restoreFromMemento(Memento memento) {
        this.state = memento.getSavedState();
        System.out.println("Originator: State after restoring from Memento: " + state);
    }

    public static class Memento {
        private final String state;

        public Memento(String stateToSave) {
            state = stateToSave;
        }

        private String getSavedState() {
            return state;
        }
    }
}

class Caretaker {
    public static void main(String[] args) {
        List&lt;Originator.Memento&gt; savedStates = new ArrayList&lt;Originator.Memento&gt;();

        Originator originator = new Originator();
        originator.set("State1");
        originator.set("State2");
        savedStates.add(originator.saveToMemento());
        originator.set("State3");
        // We can request multiple mementos, and choose which one to roll back to.
        savedStates.add(originator.saveToMemento());
        originator.set("State4");

        originator.restoreFromMemento(savedStates.get(1));   
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">观察者(Observer)</h3>
<div class="outline-text-3" id="text-3-7">
<p>
当一个对象发生变化时，该模式用于通知所有这个对象依赖的对象。
</p>
<div class="org-src-container">

<pre class="src src-java">import java.util.ArrayList;
import java.util.List;
/*from   w  ww .j  ava2  s  .  co m*/
class MyValue {
   private List&lt;Observer&gt; observers 
      = new ArrayList&lt;Observer&gt;();
   private int state;

   public int getState() {
      return state;
   }

   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }

   public void attach(Observer observer){
      observers.add(observer);    
   }

   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }   
}
abstract class Observer {
   protected MyValue subject;
   public abstract void update();
}
class PrinterObserver extends Observer{
   public PrinterObserver(MyValue subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
      System.out.println("Printer: " + subject.getState() ); 
   }
}
class EmailObserver extends Observer{

   public EmailObserver(MyValue subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
     System.out.println("Email: "+ subject.getState() ); 
   }
}
class FileObserver extends Observer{

   public FileObserver(MyValue subject){
      this.subject = subject;
      this.subject.attach(this);
   }

   @Override
   public void update() {
      System.out.println("File: " + subject.getState()); 
   }
}

public class Main {
   public static void main(String[] args) {
      MyValue subject = new MyValue();

      new FileObserver(subject);
      new EmailObserver(subject);
      new PrinterObserver(subject);

      subject.setState(15);

      subject.setState(10);
   }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">状态(State)</h3>
<div class="outline-text-3" id="text-3-8">
<p>
在该模式下，一个类的行为会随状态的变化而改变。当使用状态模式时，
会创建各种状态下的对象以及一个上下文对象，它的行为随着状态对象的
变化而变化。
</p>

<p>
要点：
</p>
<ol class="org-ol">
<li>You have a fixed set of states that the machine can be in.
</li>
<li>The machine can only be in one state at a time.
</li>
<li>A sequence of inputs or events is sent to the machine.
</li>
<li>Each state has a set of transitions, each associated with an
input and  pointing to a state.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-java">interface Statelike {

    void writeName(StateContext context, String name);

}

class StateLowerCase implements Statelike {

    @Override
    public void writeName(final StateContext context, final String name) {
        System.out.println(name.toLowerCase());
        context.setState(new StateMultipleUpperCase());
    }

}

class StateMultipleUpperCase implements Statelike {
    /** Counter local to this state */
    private int count = 0;

    @Override
    public void writeName(final StateContext context, final String name) {
        System.out.println(name.toUpperCase());
        /* Change state after StateMultipleUpperCase's writeName() gets invoked twice */
        if(++count &gt; 1) {
            context.setState(new StateLowerCase());
        }
    }

}

class StateContext {
    private Statelike myState;
    StateContext() {
        setState(new StateLowerCase());
    }

    /**
     * Setter method for the state.
     * Normally only called by classes implementing the State interface.
     * @param newState the new state of this context
     */
    void setState(final Statelike newState) {
        myState = newState;
    }

    public void writeName(final String name) {
        myState.writeName(this, name);
    }
}

public class DemoOfClientState {
    public static void main(String[] args) {
        final StateContext sc = new StateContext();

        sc.writeName("Monday");
        sc.writeName("Tuesday");
        sc.writeName("Wednesday");
        sc.writeName("Thursday");
        sc.writeName("Friday");
        sc.writeName("Saturday");
        sc.writeName("Sunday");
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">策略(Strategy)</h3>
<div class="outline-text-3" id="text-3-9">
<p>
在策略模式下，我们会创建代表不同算法的对象，以及另一个上下文对象
来运行不同的算法。
</p>
<div class="org-src-container">

<pre class="src src-java">interface MathAlgorithm {
   public int calculate(int num1, int num2);
}//from   w w w  . jav  a  2s .  c  om
class MathAdd implements MathAlgorithm{
   @Override
   public int calculate(int num1, int num2) {
      return num1 + num2;
   }
}
class MathSubstract implements MathAlgorithm{
   @Override
   public int calculate(int num1, int num2) {
      return num1 - num2;
   }
}
class MathMultiply implements MathAlgorithm{
   @Override
   public int calculate(int num1, int num2) {
      return num1 * num2;
   }
}
class MathContext {
   private MathAlgorithm algorithm;

   public MathContext(MathAlgorithm strategy){
      this.algorithm = strategy;
   }

   public int execute(int num1, int num2){
      return algorithm.calculate(num1, num2);
   }
}
public class Main {
   public static void main(String[] args) {
      MathContext context = new MathContext(new MathAdd());    
      System.out.println("10 + 5 = " + context.execute(10, 5));

      context = new MathContext(new MathSubstract());    
      System.out.println("10 - 5 = " + context.execute(10, 5));

      context = new MathContext(new MathMultiply());    
      System.out.println("10 * 5 = " + context.execute(10, 5));
   }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10">模板方法(Template Method)</h3>
<div class="outline-text-3" id="text-3-10">
<p>
在模板方法中，父类定义了一些提供给子类继承的抽象方法，另外，定义
了一个公共方法利用上述的抽象方法来实现一个业务逻辑。子类只需要关
注实现不同的业务逻辑步骤。
</p>
<div class="org-src-container">

<pre class="src src-java">abstract class UseSoftware{
   abstract void download();
   abstract void install();
   abstract void configuration();
   abstract void run();

   public void useNewSoftware(){
     download();
     install();
     configuration();
     run();   
   }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-11" class="outline-3">
<h3 id="sec-3-11">访问者(Visitor Method)</h3>
<div class="outline-text-3" id="text-3-11">
<p>
在访问者模式中，元素对象接受一个访问者对象，访问者对象自理针对元
素对象的一些操作。
不同的访问者，可以针对元素对象采用不同的算法。
</p>
<div class="org-src-container">

<pre class="src src-java">class TreeNode {/* w  ww  . j a  v a 2s  .  c  om*/
  private String name;
  public TreeNode(String name) {
    this.name = name;
  }
  public String getName() {
    return name;
  }
  public void accept(NodeVisitor v) {
    v.visit(this);
  }
}
interface NodeVisitor {
  public void visit(TreeNode n);
}
class ConsoleVisitor implements NodeVisitor {
  @Override
  public void visit(TreeNode n) {
    System.out.println("console:" + n.getName());
  }
}

class EmailVisitor implements NodeVisitor {
  @Override
  public void visit(TreeNode n) {
    System.out.println("email:" + n.getName());
  }
}

public class Main {
  public static void main(String[] args) {

    TreeNode computer = new TreeNode("Java2s.com");
    computer.accept(new ConsoleVisitor());
    computer.accept(new EmailVisitor());
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">体系结构模式</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">MVC(Model-View-Controller)</h3>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">扩展</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Null Object pattern</h3>
<div class="outline-text-3" id="text-5-1">
<p>
在空对象模式中，创建一个无任何业务逻辑意义的对象来代替真正的空对象。
使用这个空业务逻辑对象来代表空指针检查。
</p>
<div class="org-src-container">

<pre class="src src-java">abstract class AbstractEmployee {
   protected String name;
   public abstract boolean isNull();
   public abstract String getName();
}/*w  ww. j  a  v a2  s.c o m*/
class Programmer extends AbstractEmployee {
   public Programmer(String name) {
      this.name = name;    
   }
   @Override
   public String getName() {
      return name;
   }
   @Override
   public boolean isNull() {
      return false;
   }
}
class NullCustomer extends AbstractEmployee {
   @Override
   public String getName() {
      return "Not Available";
   }

   @Override
   public boolean isNull() {
      return true;
   }
}
class EmployeeFactory {
   public static final String[] names = {"Rob", "Joe", "Jack"};
   public static AbstractEmployee getCustomer(String name){
      for (int i = 0; i &lt; names.length; i++) {
         if (names[i].equalsIgnoreCase(name)){
            return new Programmer(name);
         }
      }
      return new NullCustomer();
   }
}
public class Main {
   public static void main(String[] args) {

      AbstractEmployee emp = EmployeeFactory.getCustomer("Rob");
      AbstractEmployee emp2 = EmployeeFactory.getCustomer("Bob");
      AbstractEmployee emp3 = EmployeeFactory.getCustomer("Jack");
      AbstractEmployee emp4 = EmployeeFactory.getCustomer("Tom");

      System.out.println(emp.getName());
      System.out.println(emp2.getName());
      System.out.println(emp3.getName());
      System.out.println(emp4.getName());
   }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Service Provider</h3>
<div class="outline-text-3" id="text-5-2">
<p>
研究类ImageIO
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Reactor pattern</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Java Selector   no blocking I/O
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Proactor pattern</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Java Asynchronous I/O
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">参考资料</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li><a href="https://sourcemaking.com/design_patterns">https://sourcemaking.com/design_patterns</a>
</li>
</ol>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">构造模式</a>
<ul class="nav">
<li><a href="#sec-1-1">抽象工厂(Abstract Factory)</a>
<ul class="nav">
<li><a href="#sec-1-1-1">情景示例</a></li>
</ul>
</li>
<li><a href="#sec-1-2">构造器(Builder)</a>
<ul class="nav">
<li><a href="#sec-1-2-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-1-3">工厂方法(Factory Method)</a>
<ul class="nav">
<li><a href="#sec-1-3-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-1-4">原型(Prototype)</a>
<ul class="nav">
<li><a href="#sec-1-4-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-1-5">单例(Singleton)</a>
<ul class="nav">
<li><a href="#sec-1-5-1">情景分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">结构模式</a>
<ul class="nav">
<li><a href="#sec-2-1">适配器(Adapter)</a>
<ul class="nav">
<li><a href="#sec-2-1-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-2">桥接(Bridge)</a>
<ul class="nav">
<li><a href="#sec-2-2-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-3">组合(Composite)</a>
<ul class="nav">
<li><a href="#sec-2-3-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-4">修饰器(Decorator)</a>
<ul class="nav">
<li><a href="#sec-2-4-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-5">门面(Facade)</a>
<ul class="nav">
<li><a href="#sec-2-5-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-6">享元(Flyweight)</a></li>
<li><a href="#sec-2-7">代理(Proxy)</a>
<ul class="nav">
<li><a href="#sec-2-7-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-2-8">过滤器(Filter/Criteria Pattern)</a>
<ul class="nav">
<li><a href="#sec-2-8-1">情景分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">行为模式</a>
<ul class="nav">
<li><a href="#sec-3-1">责任链(Chain of Responsibility)</a>
<ul class="nav">
<li><a href="#sec-3-1-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-3-2">命令(Command)</a>
<ul class="nav">
<li><a href="#sec-3-2-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-3-3">解释器(Interpreter)</a></li>
<li><a href="#sec-3-4">迭代器(Iterator)</a></li>
<li><a href="#sec-3-5">仲裁者(Mediator)</a>
<ul class="nav">
<li><a href="#sec-3-5-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-3-6">备忘录(Memento)</a>
<ul class="nav">
<li><a href="#sec-3-6-1">情景分析</a></li>
</ul>
</li>
<li><a href="#sec-3-7">观察者(Observer)</a></li>
<li><a href="#sec-3-8">状态(State)</a></li>
<li><a href="#sec-3-9">策略(Strategy)</a></li>
<li><a href="#sec-3-10">模板方法(Template Method)</a></li>
<li><a href="#sec-3-11">访问者(Visitor Method)</a></li>
</ul>
</li>
<li><a href="#sec-4">体系结构模式</a>
<ul class="nav">
<li><a href="#sec-4-1">MVC(Model-View-Controller)</a></li>
</ul>
</li>
<li><a href="#sec-5">扩展</a>
<ul class="nav">
<li><a href="#sec-5-1">Null Object pattern</a></li>
<li><a href="#sec-5-2">Service Provider</a></li>
<li><a href="#sec-5-3">Reactor pattern</a></li>
<li><a href="#sec-5-4">Proactor pattern</a></li>
</ul>
</li>
<li><a href="#sec-6">参考资料</a></li>
</ul>
</div>
</nav>
</div></div></div>
